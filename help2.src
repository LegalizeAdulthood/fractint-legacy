~Topic=Summary of Fractal Types, Label=HELPFRACTALS
~Format-
~Doc-
For detailed descriptions, select a hot-link below, see {Fractal Types},
or use <F2> from the fractal type selection screen.
~Doc+,Online-
SUMMARY OF FRACTAL TYPES
~Online+
~CompressSpaces-
;
; Note that prompts.c pulls formulas out of the following for <Z> screen,
; using the HF_xxx labels.  It assumes a rigid formatting structure for
; the formulas:
;    4 leading blanks (which get stripped on <Z> screen)
;    lines no wider than 76 characters (not counting initial 4 spaces)
;    formula ends at any of:
;	blank line
;	line which begins in column 1
;	format ctl char (~xxx, {xxx}, \x)
;

{=HT_BARNS barnsleyj1}
~Label=HF_BARNSJ1
      z(0) = pixel;
      z(n+1) = (z-1)*c if real(z) >= 0, else
      z(n+1) = (z+1)*modulus(c)/c
    Two parameters: real and imaginary parts of c
{=HT_BARNS barnsleyj2}
~Label=HF_BARNSJ2
      z(0) = pixel;
      if real(z(n)) * imag(c) + real(c) * imag(z((n)) >= 0
	 z(n+1) = (z(n)-1)*c
      else
	 z(n+1) = (z(n)+1)*c
    Two parameters: real and imaginary parts of c
{=HT_BARNS barnsleyj3}
~Label=HF_BARNSJ3
      z(0) = pixel;
      if real(z(n) > 0 then z(n+1) = (real(z(n))^2 - imag(z(n))^2 - 1)
	 + i * (2*real(z((n)) * imag(z((n))) else
      z(n+1) = (real(z(n))^2 - imag(z(n))^2 - 1 + real(c) * real(z(n))
	     + i * (2*real(z((n)) * imag(z((n)) + imag(c) * real(z(n))
    Two parameters: real and imaginary parts of c.
~OnlineFF
{=HT_BARNS barnsleym1}
~Label=HF_BARNSM1
      z(0) = c = pixel;
      if real(z) >= 0 then
	z(n+1) = (z-1)*c
      else
	z(n+1) = (z+1)*modulus(c)/c.
    Parameters are perturbations of z(0)
{=HT_BARNS barnsleym2}
~Label=HF_BARNSM2
      z(0) = c = pixel;
      if real(z)*imag(c) + real(c)*imag(z) >= 0
	z(n+1) = (z-1)*c
      else
	z(n+1) = (z+1)*c
    Parameters are perturbations of z(0)
{=HT_BARNS barnsleym3}
~Label=HF_BARNSM3
      z(0) = c = pixel;
      if real(z(n) > 0 then z(n+1) = (real(z(n))^2 - imag(z(n))^2 - 1)
	 + i * (2*real(z((n)) * imag(z((n))) else
      z(n+1) = (real(z(n))^2 - imag(z(n))^2 - 1 + real(c) * real(z(n))
	 + i * (2*real(z((n)) * imag(z((n)) + imag(c) * real(z(n))
    Parameters are pertubations of z(0)
~OnlineFF

{=HT_BIF bifurcation}
~Label=HF_BIFURCATION
    Pictoral representation of a population growth model.
      Let P = new population, p = oldpopulation, r = growth rate
      The model is: P = p +  r*p*(1-p).
    No parameters.
{=HT_BIF bif+sinpi}
~Label=HF_BIFPLUSSINPI
    Bifurcation variation: model is: P = p + r*sin(PI*p).
    No parameters.
{=HT_BIF bif=sinpi}
~Label=HF_BIFEQSINPI
    Bifurcation variation: model is: P = r*sin(PI*p).
    No parameters.
{=HT_BIF biflambda}
~Label=HF_BIFLAMBDA
    Bifurcation variation: model is: P = r*p*(1-p)P.
    No parameters.

~OnlineFF
{=HT_MARKS cmplxmarksjul}
~Label=HF_CMPLXMARKSJUL
    A generalization of the marksjulia fractal.
      z(0) = pixel;
      z(n+1) = (c^exp)*z(n) + c.
    Four parameters: real and imaginary parts of c and exp.
{=HT_MARKS cmplxmarksmand}
~Label=HF_CMPLXMARKSMAND
    A generalization of the marksmandel fractal.
      z(0) = c = pixel;
      z(n+1) = (c^exp)*z(n) + c.
    Four parameters: real and imaginary parts of
    perturbation of z(0) and exp.

{=HT_NEWTCMPLX complexnewton\, complexbasin}
~Label=HF_COMPLEXNEWT
    Newton fractal types extended to complex degrees. Complexnewton
    colors pixels according to the number of iterations required to
    escape to a root. Complexbasin colors pixels according to which
    root captures the orbit. The equation is based on the newton
    formula for solving the equation z^p = r
      z(0) = pixel;
      z(n+1) = ((p - 1) * z(n)^p + r)/(p * z(n)^(p - 1)).
    Four parameters: real & imaginary parts of degree p and root r
~OnlineFF

{=HT_DIFFUS diffusion}
~Label=HF_DIFFUS
    Diffusion Limited Aggregation.  Randomly moving points
    accumulate.  One parameter: border width (default 10)

{=HT_SCOTSKIN fn+fn(pix)}
~Label=HF_FNPLUSFNPIX
      c = z(0) = pixel;
      z(n+1) = fn1(z) + p*fn2(c)
    Six parameters: real and imaginary parts of the perturbation
    of z(0) and factor p, and the functions fn1, and fn2.

{=HT_SCOTSKIN fn(z*z)}
~Label=HF_FNZTIMESZ
      z(0) = pixel;
      z(n+1) = fn(z(n)*z(n))
    One parameter: the function fn.

{=HT_SCOTSKIN fn*fn}
~Label=HF_FNTIMESFN
      z(0) = pixel; z(n+1) = fn1(n)*fn2(n)
    Two parameters: the functions fn1 and fn2.
~OnlineFF

{=HT_SCOTSKIN fn*z+z}
~Label=HF_FNXZPLUSZ
      z(0) = pixel; z(n+1) = p1*fn(z(n))*z(n) + p2*z(n)
    Six parameters: the real and imaginary components of
    p1 and p2, and the functions fn1 and fn2.

{=HT_SCOTSKIN fn+fn}
~Label=HF_FNPLUSFN
      z(0) = pixel;
      z(n+1) = p1*fn1(z(n))+p2*fn2(z(n))
    Six parameters: The real and imaginary components of
    p1 and p2, and the functions fn1 and fn2.

{=HT_FORMULA formula}
    Formula interpreter - write your own formulas as text files!

{=HT_GINGER gingerbread}
~Label=HF_GINGER
    Orbit in two dimensions defined by:
      x(n+1) = 1 - y(n) + |x(n)|
      y(n+1) = x(n)
    Two parameters: initial values of x(0) and y(0).
~OnlineFF

{=HT_HENON henon}
~Label=HF_HENON
    Orbit in two dimensions defined by:
      x(n+1) = 1 + y(n) - a*x(n)*x(n)
      y(n+1) = b*x(n)
    Two parameters: a and b

{=HT_IFS Barnsley IFS}
    Barnsley IFS fractals.

{=HT_PICKMJ julfn+exp}
~Label=HF_JULFNPLUSEXP
    A generalized Clifford Pickover fractal.
      z(0) = pixel;
      z(n+1) = fn(z(n)) + e^z(n) + c.
    Three parameters: real & imaginary parts of c, and fn

{=HT_PICKMJ julfn+zsqrd}
~Label=HF_JULFNPLUSZSQRD
      z(0) = pixel;
      z(n+1) = fn(z(n)) + z(n)^2 + c
    Three parameters: real & imaginary parts of c, and fn
~OnlineFF

{=HT_JULIA julia}
~Label=HF_JULIA
    Classic Julia set fractal.
      z(0) = pixel; z(n+1) = z(n)^2 + c.
    Two parameters: real and imaginary parts of c.

{=HT_MANDJUL4 julia4}
~Label=HF_JULIA4
    Fourth-power Julia set fractals, a special case
    of julzpower kept for speed.
      z(0) = pixel;
      z(n+1) = z(n)^4 + c.
    Two parameters: real and imaginary parts of c.

{=HT_JULIBROT julibrot}
    'Julibrot' 4-dimensional fractals.

{=HT_PICKMJ julzpower}
~Label=HF_JULZPOWER
      z(0) = pixel;
      z(n+1) = z(n)^m + c.
    Three parameters: real & imaginary parts of c, exponent m
~OnlineFF

{=HT_PICKMJ julzzpwr}
~Label=HF_JULZZPWR
      z(0) = pixel;
      z(n+1) = z(n)^z(n) + z(n)^m + c.
    Three parameters: real & imaginary parts of c, exponent m

{=HT_KAM kamtorus, kamtorus3d}
~Label=HF_KAM
    Series of orbits superimposed.
    3d version has 'orbit' the z dimension.
      x(0) = y(0) = orbit/3;
      x(n+1) = x(n)*cos(a) + (x(n)*x(n)-y(n))*sin(a)
      y(n+1) = x(n)*sin(a) - (x(n)*x(n)-y(n))*cos(a)
    After each orbit, 'orbit' is incremented by a step size.
    Parameters: a, step size, stop value for 'orbit', and
    points per orbit.

{=HT_LAMBDA lambda}
~Label=HF_LAMBDA
    Classic Lambda fractal. 'Julia' variant of Mandellambda.
      z(0) = pixel;
      z(n+1) = lambda*z(n)*(1 - z(n)^2).
    Two parameters: real and imaginary parts of lambda.
~OnlineFF

{=HT_LAMBDAFN lambdafn}
~Label=HF_LAMBDAFN
      z(0) = pixel;
      z(n+1) = lambda * fn(z(n)).
    Three parameters: real, imag portions of lambda, and fn

{=HT_LORENZ lorenz, lorenz3d}
~Label=HF_LORENZ
    Lorenz attractor - orbit in three dimensions.
    In 2d the x and y components are projected to form the image.
      z(0) = y(0) = z(0) = 1;
      x(n+1) = x(n) + (-a*x(n)*dt) + (	 a*y(n)*dt)
      y(n+1) = y(n) + ( b*x(n)*dt) - (	   y(n)*dt) - (z(n)*x(n)*dt)
      z(n+1) = z(n) + (-c*z(n)*dt) + (x(n)*y(n)*dt)
    Parameters are dt, a, b, and c.

{=HT_LSYS lsystem}
    Using a turtle-graphics control language and starting with
    an initial axiom string, carries out string substitutions the
    specified number of times (the order), and plots the resulting.
~OnlineFF

{=HT_MAGNET magnet1j}
~Label=HF_MAGJ1
      z(0) = pixel;
		/ z(n)^2 + (c-1) \\
      z(n+1) = | ---------------- | ^ 2
		\\ 2*z(n) + (c-2) /
    Parameters: the real and imaginary parts of c
{=HT_MAGNET magnet1m}
~Label=HF_MAGM1
      z(0) = 0; c = pixel;
		/ z(n)^2 + (c-1) \\
      z(n+1) = | ---------------- | ^ 2
		\\ 2*z(n) + (c-2) /
    Parameters: the real & imaginary parts of perturbation of z(0)
{=HT_MAGNET magnet2j}
~Label=HF_MAGJ2
      z(0) = pixel;
		/ z(n)^3 + 3*(C-1)*z(n) + (C-1)*(C-2)	      \\
      z(n+1) = |  -------------------------------------------- | ^ 2
		\ 3*(z(n)^2) + 3*(C-2)*z(n) + (C-1)*(C-2) - 1 /
    Parameters: the real and imaginary parts of c
~OnlineFF

{=HT_MAGNET magnet2m}
~Label=HF_MAGM2
      z(0) = 0; c = pixel;
		/ z(n)^3 + 3*(C-1)*z(n) + (C-1)*(C-2)	      \\
      z(n+1) = |  -------------------------------------------- | ^ 2
		\ 3*(z(n)^2) + 3*(C-2)*z(n) + (C-1)*(C-2) - 1 /
    Parameters: the real and imaginary parts of perturbation of z(0)

{=HT_MANDEL mandel}
~Label=HF_MANDEL
    Classic Mandelbrot set fractal.
      z(0) = c = pixel;
      z(n+1) = z(n)^2 + c.
    Two parameters: real & imaginary perturbations of z(0)

{=HT_MANDJUL4 mandel4}
~Label=HF_MANDEL4
    Special case of mandelzpower kept for speed.
      z(0) = c = pixel;
      z(n+1) = z(n)^4 + c.
    Parameters: real & imaginary perturbations of z(0)

~OnlineFF
{=HT_MANDFN mandelfn}
~Label=HF_MANDFN
      z(0) = c = pixel;
      z(n+1) = c*fn(z(n)).
    Parameters: real & imaginary perturbations of z(0), and fn

{=HT_MLAMBDA mandellambda}
~Label=HF_MLAMBDA
      z(0) = .5; lambda = pixel;
      z(n+1) = lambda*z(n)*(1 - z(n)^2).
    Parameters: real & imaginary perturbations of z(0)

{=HT_PICKMJ manfn+exp}
~Label=HF_MANDFNPLUSEXP
    'Mandelbrot-Equivalent' for the julfn+exp fractal.
      z(0) = c = pixel;
      z(n+1) = fn(z(n)) + e^z(n) + C.
    Parameters: real & imaginary perturbations of z(0), and fn

{=HT_PICKMJ manfn+zsqrd}
~Label=HF_MANDFNPLUSZSQRD
    'Mandelbrot-Equivalent' for the Julfn+zsqrd fractal.
      z(0) = c = pixel;
      z(n+1) = fn(z(n)) + z(n)^2 + c.
    Parameters: real & imaginary perturbations of z(0), and fn
~OnlineFF

{=HT_SCOTSKIN manowar}
~Label=HF_MANOWAR
      c = z1(0) = z(0) = pixel;
      z(n+1) = z(n)^2 + z1(n) + c;
      z1(n+1) = z(n);
    Parameters: real & imaginary perturbations of z(0)
{=HT_SCOTSKIN manowar}
~Label=HF_MANOWARJ
      z1(0) = z(0) = pixel;
      z(n+1) = z(n)^2 + z1(n) + c;
      z1(n+1) = z(n);
    Parameters: real & imaginary perturbations of z(0)

{=HT_PICKMJ manzpower}
~Label=HF_MANZPOWER
    'Mandelbrot-Equivalent' for julzpower.
      z(0) = c = pixel;
      z(n+1) = z(n)^exp + c; try exp = e = 2.71828...
    Parameters: real & imaginary perturbations of z(0), real &
    imaginary parts of exponent exp.
~OnlineFF

{=HT_PICKMJ manzzpwr}
~Label=HF_MANZZPWR
    'Mandelbrot-Equivalent' for the julzzpwr fractal.
      z(0) = c = pixel
      z(n+1) = z(n)^z(n) + z(n)^exp + C.
    Parameters: real & imaginary perturbations of z(0), and exponent

{=HT_MARKS marksjulia}
~Label=HF_MARKSJULIA
    A variant of the julia-lambda fractal.
      z(0) = pixel;
      z(n+1) = (c^exp)*z(n) + c.
    Parameters: real & imaginary parts of c, and exponent
{=HT_MARKS marksmandel}
~Label=HF_MARKSMAND
    A variant of the mandel-lambda fractal.
      z(0) = c = pixel;
      z(n+1) = (c^exp)*z(n) + c.
    Parameters: real & imaginary perturbations of z(0), and exponent

~OnlineFF
{=HT_MARKS marksmandelpwr}
~Label=HF_MARKSMANDPWR
    The marksmandelpwr formula type generalized.
      z(0) = pixel, c = z(0) ^ (z(0) - 1):
      z(n+1) = c * fn(z(n)) + pixel,
    Parameters: real and imaginary pertubations of z(0), and fn

{=HT_NEWTBAS newtbasin}
~Label=HF_NEWTBAS
    Based on the Newton formula for finding the roots of z^p - 1.
    Pixels are colored according to which root captures the orbit.
      z(0) = pixel;
      z(n+1) = ((p-1)*z(n)^p + 1)/(p*z(n)^(p - 1)).
    Two parameters: the polynomial degree p, and a flag to turn
    on color stripes to show alternate iterations.
{=HT_NEWT newton}
~Label=HF_NEWT
    Based on the Newton formula for finding the roots of z^p - 1.
    Pixels are colored according to the iteration when the orbit
    is captured by a root.
      z(0) = pixel;
      z(n+1) = ((p-1)*z(n)^p + 1)/(p*z(n)^(p - 1)).
    One parameter: the polynomial degree p.

~OnlineFF
{=HT_PICK pickover}
~Label=HF_PICKOVER
    Orbit in three dimensions defined by:
      x(n+1) = sin(a*y(n)) - z(n)*cos(b*x(n))
      y(n+1) = z(n)*sin(c*x(n)) - cos(d*y(n))
      z(n+1) = sin(x(n))
    Parameters: a, b, c, and d.

{=HT_PLASMA plasma}
~Label=HF_PLASMA
    Random, cloud-like formations.  Requires 4 or more colors.
    A recursive algorithm repeatedly subdivides the screen and
    colors pixels according to an average of surrounding pixels
    and a random color, less random as the grid size decreases.
    One parameter: 'graininess' (.5 to 50, default = 2).

{=HT_POPCORN popcorn}
~Label=HF_POPCORN
    The orbits in two dimensions defined by:
      x(0) = xpixel, y(0) = ypixel;
      x(n+1) = x(n) - h*sin(y(n) + tan(3*y(n))
      y(n+1) = y(n) - h*sin(x(n) + tan(3*x(n))
    are plotted for each screen pixel and superimposed.
    One parameter: step size h.
~OnlineFF

{=HT_POPCORN popcornjul}
~Label=HF_POPCJUL
    Conventional Julia using the popcorn formula:
      x(0) = xpixel, y(0) = ypixel;
      x(n+1) = x(n) - h*sin(y(n) + tan(3*y(n))
      y(n+1) = y(n) - h*sin(x(n) + tan(3*x(n))
    One parameter: step size h.

{=HT_ROSS rossler3D}
~Label=HF_ROSS
    Orbit in three dimensions defined by:
      x(0) = y(0) = z(0) = 1;
      x(n+1) = x(n) - y(n)*dt -   z(n)*dt
      y(n+1) = y(n) + x(n)*dt + a*y(n)*dt
      z(n+1) = z(n) + b*dt + x(n)*z(n)*dt - c*z(n)*dt
    Parameters are dt, a, b, and c.

{=HT_SIER sierpinski}
~Label=HF_SIER
    Sierpinski gasket - Julia set producing a 'Swiss cheese triangle'
      z(n+1) = (2*x,2*y-1) if y > .5;
	  else (2*x-1,2*y) if x > .5;
	  else (2*x,2*y)
    No parameters.
~OnlineFF

{=HT_SCOTSKIN spider}
~Label=HF_SPIDER
      c(0) = z(0) = pixel;
      z(n+1) = z(n)^2 + c(n);
      c(n+1) = c(n)/2 + z(n+1)
    Parameters: real & imaginary perturbation of z(0)

{=HT_SCOTSKIN sqr(1/fn)}
~Label=HF_SQROVFN
      z(0) = pixel;
      z(n+1) = (1/fn(z(n))^2
    One parameter: the function fn.

{=HT_SCOTSKIN sqr(fn)}
~Label=HF_SQRFN
      z(0) = pixel;
      z(n+1) = fn(z(n))^2
    One parameter: the function fn.
~OnlineFF

{=HT_TEST test}
~Label=HF_TEST
    'test' point letting us (and you!) easily add fractal types via
    the c module testpt.c.  Default set up is a mandelbrot fractal.
    Four parameters: user hooks (not used by default testpt.c).

{=HT_SCOTSKIN tetrate}
~Label=HF_TETRATE
      z(0) = c = pixel;
      z(n+1) = c^z(n)
    Parameters: real & imaginary perturbation of z(0)

{=HT_MARKS tim's_error}
~Label=HF_TIMSERR
    A serendipitous coding error in marksmandelpwr brings to life
    an ancient pterodactyl!  (Try setting fn to sqr.)
      z(0) = pixel, c = z(0) ^ (z(0) - 1):
      tmp = fn(z(n))
      real(tmp) = real(tmp) * real(c) - imag(tmp) * imag(c);
      imag(tmp) = real(tmp) * imag(c) - imag(tmp) * real(c);
      z(n+1) = tmp + pixel;
    Parameters: real & imaginary pertubations of z(0) and function fn
~OnlineFF

{=HT_UNITY unity}
~Label=HF_UNITY
      z(0) = pixel;
      x = real(z(n)), y = imag(z(n))
      One = x^2 + y^2;
      y = (2 - One) * x;
      x = (2 - One) * y;
      z(n+1) = x + i*y
    No parameters.
~CompressSpaces+
;
;
;
~Topic=Fractal Types

A list of the fractal types and their mathematics can be found in the
{Summary of Fractal Types}.  Some notes about how Fractint calculates
them are in "A Little Code" in {"Fractals and the PC"}.

Fractint starts by default with the Mandelbrot set. You can change that by
using the command-line argument "TYPE=" followed by one of the
fractal type names, or by using the <T> command and
selecting the type - if parameters are needed, you will be prompted for
them.

In the text that follows, due to the limitations of the ASCII character
set, "a*b" means "a times b", and "a^b" means "a to the power b".

~Doc-
Press <PageDown> for type selection list.
~FF
Select a fractal type:

~Table=40 2 0
{ The Mandelbrot Set }
{ Julia Sets }
{ Newton domains of attraction }
{ Newton }
{ Complex Newton }
{ Lambda Sets }
{ Mandellambda Sets }
{ Plasma Clouds }
{ Lambdafn }
{ Mandelfn }
{ Barnsley Mandelbrot/Julia Sets }
{ Barnsley IFS Fractals }
{ Sierpinski Gasket }
{ Quartic Mandelbrot/Julia }
{ Distance Estimator }
{ Pickover Mandelbrot/Julia Types }
{ Pickover Popcorn }
{ Peterson Variations }
{ Unity }
{ Scott Taylor / Lee Skinner Variations }
{ Kam Torus }
{ Bifurcation }
{ Orbit Fractals }
{ Lorenz Attractors }
{ Rossler Attractors }
{ Henon Attractors }
{ Pickover Attractors }
{ Gingerbreadman }
{ Test }
{ Formula }
{ Julibrots }
{ Diffusion Limited Aggregation }
{ Magnetic Fractals }
{ L-Systems }
~EndTable
~Doc+
;
;
~Topic=The Mandelbrot Set, Label=HT_MANDEL
(type=mandel)

This set is the classic: the only one implemented in many plotting
programs, and the source of most of the printed fractal images published
in recent years. Like most of the other types in Fractint, it is simply a
graph: the x (horizontal) and y (vertical) coordinate axes represent
ranges of two independent quantities, with various colors used to
symbolize levels of a third quantity which depends on the first two. So
far, so good: basic analytic geometry.

Now things get a bit hairier. The x axis is ordinary, vanilla real
numbers. The y axis is an imaginary number, i.e. a real number times i,
where i is the square root of -1. Every point on the plane -- in this
case, your PC's display screen -- represents a complex number of the form:

    x-coordinate + i * y-coordinate

If your math training stopped before you got to imaginary and complex
numbers, this is not the place to catch up. Suffice it to say that they
are just as "real" as the numbers you count fingers with (they're used
every day by electrical engineers) and they can undergo the same kinds of
algebraic operations.

OK, now pick any complex number -- any point on the complex plane -- and
call it C, a constant. Pick another, this time one which can vary, and
call it Z. Starting with Z=0 (i.e., at the origin, where the real and
imaginary axes cross), calculate the value of the expression

    Z^2 + C

Take the result, make it the new value of the variable Z, and calculate
again. Take that result, make it Z, and do it again, and so on: in
mathematical terms, iterate the function Z(n+1) = Z(n)^2 + C. For certain
values of C, the result "levels off" after a while. For all others, it
grows without limit. The Mandelbrot set you see at the start -- the solid-
colored lake (blue by default), the blue circles sprouting from it, and
indeed every point of that color -- is the set of all points C for which
the value of Z is less than 2 after 150 iterations (150 is the default setting,
changeable via the <X> options screen or "maxiter=" parameter).
All the surrounding "contours" of other colors represent points for which Z
exceeds 2 after 149 iterations (the contour closest to the M-set itself),
148 iterations, (the next one out), and so on.

We actually don't test for Z exceeding 2 - we test Z squared against 4
instead because it is easier.  This value (FOUR usually) is known as the
"bailout" value for the calculation, because we stop iterating for the
point when it is reached.  The bailout value can be changed on the <Z>
options screen but the default is usually best.

Some features of interest:

1. Use the <X> options screen to increase the maximum number of iterations.
Notice that the boundary of the M-set becomes more and more convoluted (the
technical terms are "wiggly," "squiggly," and "utterly bizarre") as the Z-
values for points that were still within the set after 150 iterations turn
out to exceed 2 after 200, 500, or 1200. In fact, it can be proven that
the true boundary is infinitely long: detail without limit.

2. Although there appear to be isolated "islands" of blue, zoom in -- that
is, plot for a smaller range of coordinates to show more detail -- and
you'll see that there are fine "causeways" of blue connecting them to the
main set. As you zoomed, smaller islands became visible; the same is true
for them. In fact, there are no isolated points in the M-set: it is
"connected" in a strict mathematical sense.

3. The upper and lower halves of the first image are symmetric (a fact
that Fractint makes use of here and in some other fractal types to speed
plotting). But notice that the same general features -- lobed discs,
spirals, starbursts -- tend to repeat themselves (although never exactly)
at smaller and smaller scales, so that it can be impossible to judge by
eye the scale of a given image.

4. In a sense, the contour colors are window-dressing: mathematically, it
is the properties of the M-set itself that are interesting, and no
information about it would be lost if all points outside the set were
assigned the same color. If you're a serious, no-nonsense type, you may
want to cycle the colors just once to see the kind of silliness that other
people enjoy, and then never do it again. Go ahead. Just once, now. We
trust you.
;
;
~Topic=Julia Sets, Label=HT_JULIA
(type=julia)

These sets were named for mathematician Gaston Julia, and can be generated
by a simple change in the iteration process described for the
{=HT_MANDEL Mandelbrot Set}.  Start with a
specified value of C, "C-real + i * C-imaginary"; use as the initial value
of Z "x-coordinate + i * y-coordinate"; and repeat the same iteration,
Z(n+1) = Z(n)^2 + C.

There is a Julia set corresponding to every point on the complex plane --
an infinite number of Julia sets. But the most visually interesting tend
to be found for the same C values where the M-set image is busiest, i.e.
points just outside the boundary. Go too far inside, and the corresponding
Julia set is a circle; go too far outside, and it breaks up into scattered
points. In fact, all Julia sets for C within the M-set share the
"connected" property of the M-set, and all those for C outside lack it.

Fractint's spacebar toggle lets you "flip" between any view of the M-set
and the Julia set for the point C at the center of that screen. You can
then toggle back, or zoom your way into the Julia set for a while and then
return to the M-set. So if the infinite complexity of the M-set palls,
remember: each of its infinite points opens up a whole new Julia set.

Historically, the Julia sets came first: it was while looking at the M-set
as an "index" of all the Julia sets' origins that Mandelbrot noticed its
properties.

The relationship between the {=HT_MANDEL Mandelbrot} set and Julia set can
hold between
other sets as well.  Many of Fractint's types are "Mandelbrot/Julia" pairs
(sometimes called "M-sets" or "J-sets". All these are generated by
equations that are of the form z(k+1) = f(z(k),c), where the function
orbit is the sequence z(0), z(1), ..., and the variable c is a complex
parameter of the equation. The value c is fixed for "Julia" sets and is
equal to the first two parameters entered with the "params=Creal/Cimag"
command. The initial orbit value z(0) is the complex number corresponding
to the screen pixel. For Mandelbrot sets, the parameter c is the complex
number corresponding to the screen pixel. The value z(0) is c plus a
perturbation equal to the values of the first two parameters.  See
the discussion of {=HT_MLAMBDA Mandellambda Sets}.
This approach may or may not be the
"standard" way to create "Mandelbrot" sets out of "Julia" sets.

Some equations have additional parameters.  These values is entered as the
third for fourth params= value for both Julia and Mandelbrot sets. The
variables x and y refer to the real and imaginary parts of z; similarly,
cx and cy are the real and imaginary parts of the parameter c and fx(z)
and fy(z) are the real and imaginary parts of f(z). The variable c is
sometimes called lambda for historical reasons.

NOTE: if you use the "PARAMS=" argument to warp the M-set by starting with
an initial value of Z other than 0, the M-set/J-sets correspondence breaks
down and the spacebar toggle no longer works.
;
;
~Topic=Newton domains of attraction, Label=HT_NEWTBAS
(type=newtbasin)

The Newton formula is an algorithm used to find the roots of polynomial
equations by successive "guesses" that converge on the correct value as
you feed the results of each approximation back into the formula. It works
very well -- unless you are unlucky enough to pick a value that is on a
line BETWEEN two actual roots. In that case, the sequence explodes into
chaos, with results that diverge more and more wildly as you continue the
iteration.

This fractal type shows the results for the polynomial Z^n - 1, which has
n roots in the complex plane. Use the <T>ype command and enter "newtbasin"
in response to the prompt. You will be asked for a parameter, the "order"
of the equation (an integer from 3 through 10 -- 3 for x^3-1, 7 for x^7-1,
etc.). A second parameter is a flag to turn on alternating shades showing
changes in the number of iterations needed to attract an orbit. Some
people like stripes and some don't, as always, Fractint gives you a
choice!

The coloring of the plot shows the "basins of attraction" for each root of
the polynomial -- i.e., an initial guess within any area of a given color
would lead you to one of the roots. As you can see, things get a bit weird
along certain radial lines or "spokes," those being the lines between
actual roots. By "weird," we mean infinitely complex in the good old
fractal sense. Zoom in and see for yourself.

This fractal type is symmetric about the origin, with the number of
"spokes" depending on the order you select. It uses floating-point math if
you have an FPU, or a somewhat slower integer algorithm if you don't have
one.
~Doc-

See also: {Newton}
~Doc+
;
;
~Topic=Newton, Label=HT_NEWT
(type=newton)

The generating formula here is identical to that for {=HT_NEWTBAS newtbasin},
but the
coloring scheme is different. Pixels are colored not according to the root
that would be "converged on" if you started using Newton's formula from
that point, but according to the iteration when the value is close to a
root.  For example, if the calculations for a particular pixel converge to
the 7th root on the 23rd iteration, NEWTBASIN will color that pixel using
color #7, but NEWTON will color it using color #23.

If you have a 256-color mode, use it: the effects can be much livelier
than those you get with type=newtbasin, and color cycling becomes, like,
downright cosmic. If your "corners" choice is symmetrical, Fractint
exploits the symmetry for faster display. There is symmetry in newtbasin,
too, but the current version of the software isn't smart enough to exploit
it.

The applicable "params=" values are the same as newtbasin. Try "params=4."
Other values are 3 through 10. 8 has twice the symmetry and is faster. As
with newtbasin, an FPU helps.
;
;
~Topic=Complex Newton, Label=HT_NEWTCMPLX
(type=complexnewton/complexbasin)

Well, hey, "Z^n - 1" is so boring when you can use "Z^a - b" where "a" and
"b" are complex numbers!  The new "complexnewton" and "complexbasin"
fractal types are just the old {=HT_NEWT "newton"} and
{=HT_NEWTBAS "newtbasin"} fractal types with
this little added twist.  When you select these fractal types, you are
prompted for four values (the real and imaginary portions of "a" and "b").
If "a" has a complex portion, the fractal has a discontinuity along the
negative axis - relax, we finally figured out that it's *supposed* to be
there!
;
;
~Topic=Lambda Sets, Label=HT_LAMBDA
(type=lambda)

This type calculates the Julia set of the formula lambda*Z*(1-Z). That is,
the value Z[0] is initialized with the value corresponding to each pixel
position, and the formula iterated. The pixel is colored according to the
iteration when the sum of the squares of the real and imaginary parts
exceeds 4.

Two parameters, the real and imaginary parts of lambda, are required. Try
0 and 1 to see the classical fractal "dragon". Then try 0.2 and 1 for a
lot more detail to zoom in on.

It turns out that all quadratic Julia-type sets can be calculated using
just the formula z^2+c (the "classic" Julia"), so that this type is
redundant, but we include it for reason of it's prominence in the history
of fractals.
;
;
~Topic=Mandellambda Sets, Label=HT_MLAMBDA
(type=mandellambda)

This type is the "Mandelbrot equivalent" of the {=HT_LAMBDA lambda} set.
A comment is
in order here. Almost all the Fractint "Mandelbrot" sets are created from
orbits generated using formulas like z(n+1) = f(z(n),C), with z(0) and C
initialized to the complex value corresponding to the current pixel. Our
reasoning was that "Mandelbrots" are maps of the corresponding "Julias".
Using this scheme each pixel of a "Mandelbrot" is colored the same as the
Julia set corresponding to that pixel. However, Kevin Allen informs us
that the MANDELLAMBDA set appears in the literature with z(0) initialized
to a critical point (a point where the derivative of the formula is zero),
which in this case happens to be the point (.5,0). Since Kevin knows more
about Dr. Mandelbrot than we do, and Dr. Mandelbrot knows more about
fractals than we do, we defer! Starting with version 14 Fractint
calculates MANDELAMBDA Dr. Mandelbrot's way instead of our way. But ALL
THE OTHER "Mandelbrot" sets in Fractint are still calculated OUR way!
(Fortunately for us, for the classic Mandelbrot Set these two methods are
the same!)

Well now, folks, apart from questions of faithfulness to fractals named in
the literature (which we DO take seriously!), if a formula makes a
beautiful fractal, it is not wrong. In fact some of the best fractals in
Fractint are the results of mistakes! Nevertheless, thanks to Kevin for
keeping us accurate!

(See description of "initorbit=" command in {Image Calculation Parameters}
for a way to experiment with different orbit intializations).
;
;
~Topic=Plasma Clouds, Label=HT_PLASMA
(type=plasma)

Plasma clouds ARE real live fractals, even though we didn't know it at
first. They are generated by a recursive algorithm that randomly picks
colors of the corner of a rectangle, and then continues recursively
quartering previous rectangles. Random colors are averaged with those of
the outer rectangles so that small neighborhoods do not show much change,
for a smoothed-out, cloud-like effect. The more colors your video mode
supports, the better.  The result, believe it or not, is a fractal
landscape viewed as a contour map, with colors indicating constant
elevation.  To see this, save and view with the <3> command
(see {\"3D\" Images})
and your "cloud" will be converted to a mountain!

You've GOT to try {=@ColorCycling color cycling} on these (hit "+" or "-").
If you
haven't been hypnotized by the drawing process, the writhing colors will
do it for sure. We have now implemented subliminal messages to exploit the
user's vulnerable state; their content varies with your bank balance,
politics, gender, accessibility to a Fractint programmer, and so on. A
free copy of Microsoft C to the first person who spots them.

This type accepts a single parameter, which determines how abruptly the
colors change. A value of .5 yields bland clouds, while 50 yields very
grainy ones. The default value is 2. Zooming is ignored, as each plasma-
cloud screen is generated randomly.

The random number seed used for each plasma image is displayed on the
<tab> information screen, and can be entered with the command line
parameter "rseed=" to recreate a particular image.

The algorithm is based on the Pascal program distributed by Bret Mulvey as
PLASMA.ARC. We have ported it to C and integrated it with Fractint's
graphics and animation facilities. This implementation does not use
floating-point math.

Saved plasma-cloud screens are EXCELLENT starting images for fractal
"landscapes" created with the {\"3D\" commands}.
;
;
~Topic=Lambdafn, Label=HT_LAMBDAFN
(type=lambdafn)

Function=[sin|cos|sinh|cosh|exp|log|sqr|...]) is specified with this type.
Prior to version 14, these types were lambdasine, lambdacos, lambdasinh,
lambdacos, and lambdaexp.  Where we say "lambdasine" or some such below,
the good reader knows we mean "lambdafn with function=sin".)

These types calculate the Julia set of the formula lambda*fn(Z), for
various values of the function "fn", where lambda and Z are both complex.
Two values, the real and imaginary parts of lambda, should be given in the
"params=" option.  For the feathery, nested spirals of LambdaSines and the
frost-on-glass patterns of LambdaCosines, make the real part = 1, and try
values for the imaginary part ranging from 0.1 to 0.4 (hint: values near
0.4 have the best patterns). In these ranges the Julia set "explodes". For
the tongues and blobs of LambdaExponents, try a real part of 0.379 and an
imaginary part of 0.479.

A co-processor used to be almost mandatory: each LambdaSine/Cosine
iteration calculates a hyperbolic sine, hyperbolic cosine, a sine, and a
cosine (the LambdaExponent iteration "only" requires an exponent, sine,
and cosine operation)!	However, Fractint now computes these
transcendental functions with fast integer math. In a few cases the fast
math is less accurate, so we have kept the old slow floating point code.
To use the old code, invoke with the float=yes option, and, if you DON'T
have a co-processor, go on a LONG vacation!
;
;
~Topic=Mandelfn, Label=HT_MANDFN
(type=mandelfn)

Function=[sin|cos|sinh|cosh|exp|log|sqr|...]) is specified with this type.
Prior to version 14, these types were mandelsine, mandelcos, mandelsinh,
mandelcos, and mandelexp. Same comment about our lapses into the old
terminology as above!

These are "pseudo-Mandelbrot" mappings for the {=HT_LAMBDAFN LambdaFn}
Julia functions.
They map to their corresponding Julia sets via the spacebar command in
exactly the same fashion as the original M/J sets.  In general, they are
interesting mainly because of that property (the function=exp set in
particular is rather boring). Generate the appropriate "Mandelfn" set,
zoom on a likely spot where the colors are changing rapidly, and hit the
spacebar key to plot the Julia set for that particular point.

Try "FRACTINT TYPE=MANDELFN CORNERS=4.68/4.76/-.03/.03 FUNCTION=COS" for a
graphic demonstration that we're not taking Mandelbrot's name in vain
here. We didn't even know these little buggers were here until Mark
Peterson found this a few hours before the version incorporating Mandelfns
was released.

Note: If you created images using the lambda or mandel "fn" types prior to
version 14, and you wish to update the fractal information in the "*.fra"
file, simply read the files and save again. You can do this in batch mode
via a command line like:

     "fractint oldfile.fra savename=newfile.gif batch=yes"

For example, this procedure can convert a version 13 "type=lambdasine"
image to a version 14 "type=lambdafn function=sin" GIF89a image.  We do
not promise to keep this "backward compatibility" past version 14 - if you
want to keep the fractal information in your *.fra files accurate, we
recommend conversion.  See {GIF Save File Format}.
;
;
~Topic=Barnsley Mandelbrot/Julia Sets, Label=HT_BARNS
(type=barnsleym1/.../j3)

Michael Barnsley has written a fascinating college-level text, "Fractals
Everywhere," on fractal geometry and its graphic applications. (See
{Bibliography}.) In it, he applies the principle of the M and J
sets to more general functions of two complex variables.

We have incorporated three of Barnsley's examples in Fractint. Their
appearance suggests polarized-light microphotographs of minerals, with
patterns that are less organic and more crystalline than those of the M/J
sets. Each example has both a "Mandelbrot" and a "Julia" type. Toggle
between them using the spacebar.

The parameters have the same meaning as they do for the "regular"
Mandelbrot and Julia. For types M1, M2, and M3, they are used to "warp"
the image by setting the initial value of Z. For the types J1 through J3,
they are the values of C in the generating formulas.

Be sure to try the <O>rbit function while plotting these types.
;
;
~Topic=Barnsley IFS Fractals, Label=HT_IFS
(type=ifs)

One of the most remarkable spin-offs of fractal geometry is the ability to
"encode" realistic images in very small sets of numbers -- parameters for
a set of functions that map a region of two-dimensional space onto itself.
In principle (and increasingly in practice), a scene of any level of
complexity and detail can be stored as a handful of numbers, achieving
amazing "compression" ratios... how about a super-VGA image of a forest,
more than 300,000 pixels at eight bits apiece, from a 1-KB "seed" file?

Again, Michael Barnsley and his co-workers at the Georgia Institute of
Technology are to be thanked for pushing the development of these iterated
function systems (IFS).

When you select this fractal type, Fractint scans the current IFS file
(default is FRACTINT.IFS, a set of definitions supplied with Fractint) for
IFS definitions, then prompts you for the IFS name you wish to run. Fern
and 3dfern are good ones to start with. You can press <F6> at the
selection screen if you want to select a different .IFS file you've
written.

Note that some Barnsley IFS values generate images quite a bit smaller
than the initial (default) screen. Just bring up the zoom box, center it
on the small image, and hit <Enter> to get a full-screen image.

To change the number of dots Fractint generates for an IFS image before
stopping, you can change the "maximum iterations" parameter on the <X>
options screen.

Fractint supports two types of IFS images: 2D and 3D. In order to fully
appreciate 3D IFS images, since your monitor is presumably 2D, we have
added rotation, translation, and perspective capabilities. These share
values with the same variables used in Fractint's other 3D facilities; for
their meaning see {"Rectangular Coordinate Transformation"}.
You can enter these values from the command line using:

rotation=xrot/yrot/zrot       (try 30/30/30)\
shift=xshift/yshift	      (shifts BEFORE applying perspective!)\
perspective=viewerposition    (try 200)\

Alternatively, entering <I> from main screen will allow you to modify
these values. The defaults are the same as for regular 3D, and are not
always optimum for 3D IFS. With the 3dfern IFS type, try
rotation=30/30/30. Note that applying shift when using perspective changes
the picture -- your "point of view" is moved.

A truly wild variation of 3D may be seen by entering "2" for the stereo
mode (see {"Stereo 3D Viewing"}),
putting on red/blue "funny glasses", and watching the fern develop
with full depth perception right there before your eyes!

This feature USED to be dedicated to Bruce Goren, as a bribe to get him to
send us MORE knockout stereo slides of 3D ferns, now that we have made it
so easy! Bruce, what have you done for us *LATELY* ?? (Just kidding,
really!)

Each line in an IFS definition (look at FRACTINT.IFS with your editor for
examples) contains the parameters for one of the generating functions,
e.g. in FERN:
~Format-
   a	b     c    d	e    f	  p
 ___________________________________
   0	 0    0  .16	0    0	 .01
 .85   .04 -.04  .85	0  1.6	 .85
 .2   -.26  .23  .22	0  1.6	 .07
-.15   .28  .26  .24	0  .44	 .07

The values on each line define a matrix, vector, and probability:
    matrix   vector  prob
    |a b|     |e|     p
    |c d|     |f|
~Format+

The "p" values are the probabilities assigned to each function (how often
it is used), which add up to one. Fractint supports up to 32 functions,
although usually three or four are enough.

3D IFS definitions are a bit different.  The name is followed by (3D) in
the definition file, and each line of the definition contains 13 numbers:
a b c d e f g h i j k l p, defining:
    matrix   vector  prob\
    |a b c|   |j|     p\
    |d e f|   |k|\
    |g h i|   |l|\

You can experiment with changes to IFS definitions interactively by using
Fractint's <Z> command.  After selecting an IFS definition, hit <Z> to
bring up the IFS editor. This editor displays the current IFS values, lets
you modify them, and lets you save your modified values as a text file
which you can then merge into an XXX.IFS file for future use with
Fractint.

The program FDESIGN can be used to design IFS fractals - see
{=@FDESIGN FDESIGN}.

You can save the points in your IFS fractal in the file ORBITS.RAW which is
overwritten each time a fractal is generated. The program Acrospin can
read this file and will let you view the fractal from in any angle using
the cursor keys. See {=@ACROSPIN Acrospin}.
;
;
~Topic=Sierpinski Gasket, Label=HT_SIER
(type=sierpinski)

Another pre-Mandelbrot classic, this one found by W. Sierpinski around
World War I. It is generated by dividing a triangle into four congruent
smaller triangles, doing the same to each of them, and so on, yea, even
unto infinity. (Notice how hard we try to avoid reiterating "iterating"?)

If you think of the interior triangles as "holes", they occupy more and
more of the total area, while the "solid" portion becomes as hopelessly
fragile as that gasket you HAD to remove without damaging it -- you
remember, that Sunday afternoon when all the parts stores were closed?
There's a three-dimensional equivalent using nested tetrahedrons instead
of triangles, but it generates too much pyramid power to be safely
unleashed yet.

There are no parameters for this type. We were able to implement it with
integer math routines, so it runs fairly quickly even without an FPU.
;
;
~Topic=Quartic Mandelbrot/Julia, Label=HT_MANDJUL4
(type=mandel4/julia4)

These fractal types are the moral equivalent of the original M and J sets,
except that they use the formula Z(n+1) = Z(n)^4 + C, which adds
additional pseudo-symmetries to the plots. The "Mandel4" set maps to the
"Julia4" set via -- surprise! -- the spacebar toggle. The M4 set is kind
of boring at first (the area between the "inside" and the "outside" of the
set is pretty thin, and it tends to take a few zooms to get to any
interesting sections), but it looks nice once you get there. The Julia
sets look nice right from the start.

Other powers, like Z(n)^3 or Z(n)^7, work in exactly the same fashion. We
used this one only because we're lazy, and Z(n)^4 = (Z(n)^2)^2.
;
;
~Topic=Distance Estimator
(distest=nnn/nnn)

This used to be type=demm and type=demj.  These types have not died, but
are only hiding!  They are equivalent to the mandel and julia types with
the "distest=" option selected with a predetermined value.

The {Distance Estimator Method}
can be used to produce higher quality images of M and J sets,
especially suitable for printing in black and white.

If you have some *.fra files made with the old types demm/demj, you may
want to convert them to the new form.  See the {=HT_MANDFN Mandelfn}
section for directions to carry out the conversion.
;
;
~Topic=Pickover Mandelbrot/Julia Types, Label=HT_PICKMJ
(type=manfn+zsqrd/julfn+zsqrd, manzpowr/julzpowr, manzzpwr/julzzpwr,
manfn+exp/julfn+exp - formerly included man/julsinzsqrd and
man/julsinexp which have now been generalized)

These types have been explored by Clifford A. Pickover, of the IBM Thomas
J. Watson Research center. As implemented in Fractint, they are regular
Mandelbrot/Julia set pairs that may be plotted with or without the
{=@Biomorphs "biomorph"} option Pickover used to create organic-looking
beasties (see
below). These types are produced with formulas built from the functions
z^z, z^n, sin(z), and e^z for complex z. Types with "power" or "pwr" in
their name have an exponent value as a third parameter. For example,
type=manzpower params=0/0/2 is our old friend the classical Mandelbrot,
and type=manzpower params=0/0/4 is the Quartic Mandelbrot. Other values of
the exponent give still other fractals.  Since these WERE the original
"biomorph" types, we should give an example.  Try:

    FRACTINT type=manfn+zsqrd biomorph=0 corners=-8/8/-6/6 function=sin

to see a big biomorph digesting little biomorphs!
;
;
~Topic=Pickover Popcorn, Label=HT_POPCORN
(type=popcorn/popcornjul)

Here is another Pickover idea. This one computes and plots the orbits of
the dynamic system defined by:

	 x(n+1) = x(n) - h*sin(y(n)+tan(3*y(n))\
	 y(n+1) = y(n) - h*sin(x(n)+tan(3*x(n))\

with the initializers x(0) and y(0) equal to ALL the complex values within
the "corners" values, and h=.01.  ALL these orbits are superimposed,
resulting in "popcorn" effect.  You may want to use a maxiter value less
than normal - Pickover recommends a value of 50.  As a bonus,
type=popcornjul shows the Julia set generated by these same equations with
the usual escape-time coloring. Turn on orbit viewing with the "O"
command, and as you watch the orbit pattern you may get some insight as to
where the popcorn comes from. Although you can zoom and rotate popcorn,
the results may not be what you'd expect, due to the superimposing of
orbits and arbitrary use of color. Just for fun we added type popcornjul,
which is the plain old Julia set calculated from the same formula.
;
;
~Topic=Peterson Variations, Label=HT_MARKS
(type=marksmandel, marksjulia, cmplxmarksmand, cmplxmarksjul, marksmandelpwr,
tim's_error)

These fractal types are contributions of Mark Peterson. MarksMandel and
MarksJulia are two families of fractal types that are linked in the same
manner as the classic Mandelbrot/Julia sets: each MarksMandel set can be
considered as a mapping into the MarksJulia sets, and is linked with the
spacebar toggle. The basic equation for these sets is:
      Z(n+1) = ((lambda^n) * Z(n)^2) + lambda
where Z(0) = 0.0 and lambda is (x + iy) for MarksMandel. For MarksJulia,
Z(0) = (x + iy) and lambda is a constant (taken from the MarksMandel
spacebar toggle, if that method is used). The exponent is a positive
integer or a complex number. We call these "families" because each value
of the exponent yields a different MarksMandel set, which turns out to be
a kinda-polygon with (exponent+1) sides. The exponent value is the third
parameter, after the "initialization warping" values. Typically one would
use null warping values, and specify the exponent with something like
"PARAMS=0/0/4", which creates an unwarped, pentagonal MarksMandel set.

In the process of coding MarksMandelPwr formula type, Tim Wegner
created the type "tim's_error" after making an interesting coding mistake.
;
;
~Topic=Unity, Label=HT_UNITY
(type=unity)

This Peterson variation began with curiosity about other "Newton-style"
approximation processes. A simple one,

   One = (x * x) + (y * y); y = (2 - One) * x;	 x = (2 - One) * y;

produces the fractal called Unity.

One of its interesting features is the "ghost lines." The iteration loop
bails out when it reaches the number 1 to within the resolution of a
screen pixel. When you zoom a section of the image, the bailout criterion
is adjusted, causing some lines to become thinner and others thicker.

Only one line in Unity that forms a perfect circle: the one at a radius of
1 from the origin. This line is actually infinitely thin. Zooming on it
reveals only a thinner line, up (down?) to the limit of accuracy for the
algorithm. The same thing happens with other lines in the fractal, such as
those around |x| = |y| = (1/2)^(1/2) = .7071

Try some other tortuous approximations using the {=HT_TEST TEST stub} and
let us know what you come up with!
;
;
~Topic=Scott Taylor / Lee Skinner Variations, Label=HT_SCOTSKIN
(type=fn(z*z), fn*fn, fn*z+z, fn+fn, sqr(1/fn), sqr(fn), spider,
tetrate, manowar)

Two of Fractint's faithful users went bonkers when we introduced the
"formula" type, and came up with all kinds of variations on escape-time
fractals using trig functions.	We decided to put them in as regular
types, but there were just too many! So we defined the types with variable
functions and let you, the, overwhelmed user, specify what the functions
should be! Thus Scott Taylor's "z = sin(z) + z^2" formula type is now the
"fn+fn" regular type, and EITHER function can be one of sin, cos, tan, cotan,
sinh, cosh, tanh, cotanh, exp, log, sqr, recip, ident, or cosxx.
Plus we give you 4 parameters to set, the complex
coefficients of the two functions!  Thus the innocent-looking "fn+fn" type
is really 66 different types in disguise, not counting the damage
done by the parameters!

Lee informs us that you should not judge fractals by their "outer"
appearance. For example, the images produced by z = sin(z) + z^2 and z =
sin(z) - z^2 look very similar, but are different when you zoom in.
;
;
~Topic=Kam Torus, Label=HT_KAM
(type=kamtorus, kamtorus3d)

This type is created by superimposing orbits generated by a set of
equations, with a variable incremented each time.

	 x(0) = y(0) = orbit/3;\
	 x(n+1) = x(n)*cos(a) + (x(n)*x(n)-y(n))*sin(a)\
	 y(n+1) = x(n)*sin(a) - (x(n)*x(n)-y(n))*cos(a)\

After each orbit, 'orbit' is incremented by a step size. The parameters
are angle "a", step size for incrementing 'orbit', stop value for 'orbit',
and points per orbit. Try this with a stop value of 5 with sound=x for
some weird fractal music (ok, ok, fractal noise)! You will also see the
KAM Torus head into some chaotic territory that Scott Taylor wanted to
hide from you by setting the defaults the way he did, but now we have
revealed all!

The 3D variant is created by treating 'orbit' as the z coordinate.

With both variants, you can adjust the "maxiter" value (<X> options
screen or parameter maxiter=) to change the number of orbits plotted.
;
;
~Topic=Bifurcation, Label=HT_BIF
(type=bifxxx)

The wonder of fractal geometry is that such complex forms can arise from
such simple generating processes. A parallel surprise has emerged in the
study of dynamical systems: that simple, deterministic equations can yield
chaotic behavior, in which the system never settles down to a steady state
or even a periodic loop. Often such systems behave normally up to a
certain level of some controlling parameter, then go through a transition
in which there are two possible solutions, then four, and finally a
chaotic array of possibilities.

This emerged many years ago in biological models of population growth.
Consider a (highly over-simplified) model in which the rate of growth is
partly a function of the size of the current population:

New Population =  Growth Rate * Old Population * (1 - Old Population)

where population is normalized to be between 0 and 1. At growth rates less
than 200 percent, this model is stable: for any starting value, after
several generations the population settles down to a stable level. But for
rates over 200 percent, the equation's curve splits or "bifurcates" into
two discrete solutions, then four, and soon becomes chaotic.

Type=bifurcation illustrates this model. (Although it's now considered a
poor one for real populations, it helped get people thinking about chaotic
systems.) The horizontal axis represents growth rates, from 190 percent
(far left) to 400 percent; the vertical axis normalized population values,
from 0 to 4/3. Notice that within the chaotic region, there are narrow
bands where there is a small, odd number of stable values. It turns out
that the geometry of this branching is fractal; zoom in where changing
pixel colors look suspicious, and see for yourself.

The default display has been filtered by allowing the population to settle
from its initial value for 5000 cycles before plotting maxiter population
values. To override this filter value, specify a new (smaller) one as the
first "PARAMS=" value. "PARAMS=1" produces an unfiltered map.

Many formulae can be used to produce bifurcations.  Mitchel Feigenbaum
studied lots of bifurcations in the mid-70's, using a HP-65 calculator
(IBM PCs, Fractals, and Fractint, were all Sci-Fi then !). He studied
where bifurcations occurred, for the formula r*p*(1-p), the one described
above.	He found that the ratios of lengths of adjacent areas of
bifurcation were four and a bit.  These ratios vary, but, as the growth
rate increases, they tend to a limit of 4.669+.  This helped him guess
where bifurcation points would be, and saved lots of time.

When he studied bifurcations of r*sin(PI*p) he found a similar pattern,
which is not surprising in itself.  However, 4.669+ popped out, again.
Different formulae, same number ?  Now, THAT's surprising !  He tried many
other formulae and ALWAYS got 4.669+ - Hot Damn !!!  So hot, in fact, that
he phoned home and told his Mom it would make him Famous ! He also went on
to tell other scientists.  The rest is History...

(It has been conjectured that if Feigenbaum had a copy of Fractint, and
used it to study bifurcations, he may never have found his Number, as it
only became obvious from long perusal of hand-written lists of values,
without the distraction of wild color-cycling effects !).

We now know that this number is as universal as PI or E. It appears in
situations ranging from fluid-flow turbulence, electronic oscillators,
chemical reactions, and even the Mandelbrot Set - yup, fraid so:
"budding" of the Mandelbrot Set along the negative real axis occurs at
intervals determined by Feigenbaum's Number, 4.669201660910.....

Fractint does not make direct use of the Feigenbaum Number (YET !).
However, it does now reflect the fact that there is a whole sub-species of
Bifurcation-type fractals.  Those implemented to date, and the related
formulae, (writing P for pop[n+1] and p for pop[n]) are :

  bifurcation	P =  p + r*p*(1-p)	Verhulst Bifurcations.\
  biflambda	P =	 r*p*(1-p)	Real equivalent of Lambda Sets.\
  bif+sinpi	P =  p + r*sin(PI*p)	Population scenario based on...\
  bif=sinpi	P =	 r*sin(PI*p)	...Feigenbaum's second formula.\

It took a while for bifurcations to appear here, despite them being over a
century old, and intimately related to chaotic systems. However, they are
now truly alive and well in Fractint!
;
;
~Topic=Orbit Fractals

Orbit Fractals are generated by plotting an orbit path in two or three
dimensional space.

See {Lorenz Attractors}, {Rossler Attractors},
{Henon Attractors}, {Pickover Attractors}, and {Gingerbreadman}.

The orbit trajectory for these types can be saved in the file ORBITS.RAW
by invoking
Fractint with the "orbitsave=yes" command-line option.  This file will
be overwritten each time you generate a new fractal, so rename it if you
want to save it.  A nifty program called Acrospin can read these files and
rapidly rotate them in 3-D - see {=@ACROSPIN Acrospin}.
;
;
~Topic=Lorenz Attractors, Label=HT_LORENZ
(type=lorenz/lorenz3d)

The "Lorenz Attractor" is a "simple" set of three deterministic equations
developed by Edward Lorenz while studying the non- repeatability of
weather patterns.  The weather forecaster's basic problem is that even
very tiny changes in initial patterns ("the beating of a butterfly's
wings" - the official term is "sensitive dependence on initial
conditions") eventually reduces the best weather forecast to rubble.

The lorenz attractor is the plot of the orbit of a dynamic system
consisting of three first order non-linear differential equations. The
solution to the differential equation is vector-valued function of one
variable.  If you think of the variable as time, the solution traces an
orbit.	The orbit is made up of two spirals at an angle to each other in
three dimensions. We change the orbit color as time goes on to add a
little dazzle to the image.  The equations are:

		dx/dt = -a*x + a*y\
		dy/dt =  b*x - y   -z*x\
		dz/dt = -c*z + x*y\

We solve these differential equations approximately using a method known
as the first order taylor series.  Calculus teachers everywhere will kill
us for saying this, but you treat the notation for the derivative dx/dt as
though it really is a fraction, with "dx" the small change in x that
happens when the time changes "dt".  So multiply through the above
equations by dt, and you will have the change in the orbit for a small
time step. We add these changes to the old vector to get the new vector
after one step. This gives us:

	     xnew = x + (-a*x*dt) + (a*y*dt)\
	     ynew = y + (b*x*dt) - (y*dt) - (z*x*dt)\
	     znew = z + (-c*z*dt) + (x*y*dt)\

	     (default values: dt = .02, a = 5, b = 15, c = 1)

We connect the successive points with a line, project the resulting 3D
orbit onto the screen, and voila! The Lorenz Attractor!

We have added two versions of the Lorenz Attractor.  "Type=lorenz" is the
Lorenz attractor as seen in everyday 2D.  "Type=lorenz3d" is the same set
of equations with the added twist that the results are run through our
perspective 3D routines, so that you get to view it from different angles
(you can modify your perspective "on the fly" by using the <I> command.)
If you set the "stereo" option to "2", and have red/blue funny glasses on,
you will see the attractor orbit with depth perception.

Hint: the default perspective values (x = 60, y = 30, z = 0) aren't the
best ones to use for fun Lorenz Attractor viewing.  Experiment a bit -
start with rotation values of 0/0/0 and then change to 20/0/0 and 40/0/0
to see the attractor from different angles.- and while you're at it, use a
non-zero perspective point Try 100 and see what happens when you get
*inside* the Lorenz orbits.  Here comes one - Duck!  While you are at it,
turn on the sound with the "X". This way you'll at least hear it coming!

Different Lorenz attractors can be created using different parameters.
Four parameters are used. The first is the time-step (dt). The default
value is .02. A smaller value makes the plotting go slower; a larger value
is faster but rougher. A line is drawn to connect successive orbit values.
The 2nd, third, and fourth parameters are coefficients used in the
differential equation (a, b, and c). The default values are 5, 15, and 1.
Try changing these a little at a time to see the result.
;
;
~Topic=Rossler Attractors, Label=HT_ROSS
(type=rossler3D)

This fractal is named after the German Otto Rossler, a non-practicing
medical doctor who approached chaos with a bemusedly philosophical
attitude.  He would see strange attractors as philosophical objects. His
fractal namesake looks like a band of ribbon with a fold in it. All we can
say is we used the same calculus-teacher-defeating trick of multiplying
the equations by "dt" to solve the differential equation and generate the
orbit.	This time we will skip straight to the orbit generator - if you
followed what we did above with type {=HT_LORENZ Lorenz} you can easily
reverse engineer the differential equations.

	     xnew = x - y*dt -	 z*dt\
	     ynew = y + x*dt + a*y*dt\
	     znew = z + b*dt + x*z*dt - c*z*dt\

Default parameters are dt = .04, a = .2, b = .2, c = 5.7
;
;
~Topic=Henon Attractors, Label=HT_HENON
(type=henon)

Michel Henon was an astronomer at Nice observatory in southern France. He
came to the subject of fractals via investigations of the orbits of
astronomical objects.  The strange attractor most often linked with
Henon's name comes not from a differential equation, but from the world of
discrete mathematics - difference equations. The Henon map is an example
of a very simple dynamic system that exhibits strange behavior. The orbit
traces out a characteristic banana shape, but on close inspection, the
shape is made up of thicker and thinner parts.	Upon magnification, the
thicker bands resolve to still other thick and thin components.  And so it
goes forever! The equations that generate this strange pattern perform the
mathematical equivalent of repeated stretching and folding, over and over
again.

	     xnew =  1 + y - a*x*x\
	     ynew =  b*x\

The default parameters are a=1.4 and b=.3.
;
;
~Topic=Pickover Attractors, Label=HT_PICK
(type=pickover)

Clifford A. Pickover of the IBM Thomas J. Watson Research center is such a
creative source for fractals that we attach his name to this one only with
great trepidation.  Probably tomorrow he'll come up with another one and
we'll be back to square one trying to figure out a name!

This one is the three dimensional orbit defined by:

	     xnew = sin(a*y) - z*cos(b*x)\
	     ynew = z*sin(c*x) - cos(d*y)\
	     znew = sin(x)\

Default parameters are: a = 2.24, b = .43, c = -.65, d = -2.43
;
;
~Topic=Gingerbreadman, Label=HT_GINGER
(type=gingerbreadman)

This simple fractal is a charming example stolen from "Science of Fractal
Images", p. 149.

	     xnew = 1 - y + |x|\
	     ynew = x

The initial x and y values are set by parameters, defaults x=-.1, y = 0.
;
;
~Topic=Test, Label=HT_TEST
(type=test)

This is a stub that we (and you!) use for trying out new fractal types.
"Type=test" fractals make use of Fractint's structure and features for
whatever code is in the routine 'testpt()' (located in the small source
file TESTPT.C) to determine the color of a particular pixel.

If you have a favorite fractal type that you believe would fit nicely into
Fractint, just rewrite the C function in TESTPT.C (or use the prototype
function there, which is a simple M-set implementation) with an algorithm
that computes a color based on a point in the complex plane.

After you get it working, send your code to one of the authors and we
might just add it to the next release of Fractint, with full credit to
you. Our criteria are: 1) an interesting image and 2) a formula
significantly different from types already supported. (Bribery may also
work. THIS author is completely honest, but I don't trust those other
guys.) Be sure to include an explanation of your algorithm and the
parameters supported, preferably formatted as you see here to simplify
folding it into the documentation.
;
;
~Topic=Formula, Label=HT_FORMULA
(type=formula)

This is a "roll-your-own" fractal interpreter - you don't even need a
compiler!

To run a "type=formula" fractal, you first need a text file containing
formulas (there's a sample file - FRACTINT.FRM - included with this
distribution).	When you select the "formula" fractal type, Fractint scans
the current formula file (default is FRACTINT.FRM) for formulas, then
prompts you for the formula name you wish to run.  After prompting for any
parameters, the formula is parsed for syntax errors and then the fractal
is generated. If you want to use a different formula file, press <F6> when
you are prompted to select a formula name.

There are two command-line options that work with type=formula
("formulafile=" and "formulaname="), useful when you are using this
fractal type in batch mode.

The following documentation is supplied by Mark Peterson, who wrote the
formula interpreter:

Formula fractals allow you to create your own fractal formulas.  The
general format is:

   Mandelbrot(XAXIS) \{ z = Pixel:  z = sqr(z) + pixel, |z| <= 4 \}\
      | 	|	   |		    |		   |\
     Name     Symmetry	  Initial	  Iteration	  Bailout\
			  Condition			  Criteria\

Initial conditions are set, then the iterations performed until the
bailout criteria is true or 'z' turns into a periodic loop.
All variables are created automatically by their usage and treated as
complex.  If you declare 'v = 2' then the variable 'v' is treated as a
complex with an imaginary value of zero.

~Format-
	  Predefined Variables (x, y)
	  --------------------------------------------
	  z		 used for periodicity checking
	  p1		 parameters 1 and 2
	  p2		 parameters 3 and 4
	  pixel 	 screen coordinates

	  Precedence
	  --------------------------------------------
	  1		 sin(), cos(), sinh(), cosh(), cosxx(),
			 tan(), cotan(), tanh(), cotanh(),
			 sqr, log(), exp(), abs(), conj(), real(),
			 imag(), flip(), fn1(), fn2(), fn3(), fn4()
	  2		 - (negation), ^ (power)
	  3		 * (multiplication), / (division)
	  4		 + (addition), - (subtraction)
	  5		 = (assignment)
	  6		 < (less than), <= (less than or equal to)
~Format+

Precedence may be overridden by use of parenthesis.  Note the modulus
squared operator |z| is also parenthetic and always sets the imaginary
component to zero.  This means 'c * |z - 4|' first subtracts 4 from z,
calculates the modulus squared then multiplies times 'c'.  Nested modulus
squared operators require overriding parenthesis:

	  c * |z + (|pixel|)|

The functions fn1(...) to fn4(...) are variable functions - when used,
the user is prompted at run time (on the <Z> screen) to specify one of
sin, cos, sinh, cosh, exp, log, sqr, etc. for each required variable function.

The formulas are performed using either integer or floating point
mathematics depending on the <F> floating point toggle.  If you do not
have an FPU then type MPC math is performed in lieu of traditional
floating point.

Remember that when using integer math there is a limited dynamic range, so
what you think may be a fractal could really be just a limitation of the
integer math range.  God may work with integers, but His dynamic range is
many orders of magnitude greater than our puny 32 bit mathematics!  Always
verify with the floating point <F> toggle.
;
;
~Topic=Julibrots, Label=HT_JULIBROT
(type=julibrot)

The following documentation is supplied by Mark Peterson, who "invented"
the Julibrot algorithm.

There is a very close relationship between the Mandelbrot set and Julia
sets of the same equation.  To draw a Julia set you take the basic
equation and vary the initial value according to the two dimensions of
screen leaving the constant untouched.	This method diagrams two
dimensions of the equation, 'x' and 'iy', which I refer to as the Julia x
and y.

     z(0) = screen coordinate (x + iy)\
     z(1) = (z(0) * z(0)) + c, where c = (a + ib)\
     z(2) = (z(1) * z(0)) + c\
     z(3) = . . . .\

The Mandelbrot set is a composite of all the Julia sets.  If you take the
center pixel of each Julia set and plot it on the screen coordinate
corresponding to the value of c, a + ib, then you have the Mandelbrot set.

     z(0) = 0\
     z(1) = (z(0) * z(0)) + c, where c = screen coordinate (a + ib)\
     z(2) = (z(1) * z(1)) + c\
     z(3) = . . . .\

I refer to the 'a' and 'ib' components of 'c' as the Mandelbrot 'x' and
'y'.

All the 2 dimensional Julia sets correspond to a single point on the 2
dimensional Mandelbrot set, making a total of 4 dimensions associated with
our equation.  Visualizing 4 dimensional objects is not as difficult as it
may sound at first if you consider we live in a 4 dimensional world.  The
room around you is three dimensions and as you read this text you are
moving through the fourth dimension of time. You and everything around
your are 4 dimensional objects - which is to say 3 dimensional objects
moving through time.  We can think of the 4 dimensions of our equation in
the same manner, this is as a 3 dimensional object evolving over time -
sort of a 3 dimensional fractal movie.	The fun part of it is you get to
pick the dimension representing time!

To construct the 4 dimensional object into something you can view on the
computer screen you start with the simple 2 dimensions of the Julia set.
I'll treat the two Julia dimensions as the spatial dimensions of height
and width, and the Mandelbrot 'y' dimension as the third spatial dimension
of depth.  This leaves the Mandelbrot 'x' dimension as time.  Draw the
Julia set associated with the Mandelbrot coordinate (-.83, -.25), but
instead of setting the color according to the iteration level it bailed
out on, make it a two color drawing where the pixels are black for
iteration levels less than 30, and another color for iteration levels
greater than or equal to 30.  Now increment the Mandelbrot 'y' coordinate
by a little bit, say (-.83, -.2485), and draw another Julia set in the
same manner using a different color for bailout values of 30 or greater.
Continue doing this until you reach (-.83, .25).  You now have a three
dimensional representation of the equation at time -.83.  If you make the
same drawings for points in time before and after -.83 you can construct a
3 dimensional movie of the equation which essentially is a full 4
dimensional representation.

In the Julibrot fractal available with this release of Fractint the
spatial dimensions of height and width are always the Julia dimensions.
The dimension of depth is determined by the Mandelbrot coordinates.  The
program will consider the dimension of depth as the line between the two
Mandelbrot points.  To draw the image in our previous example you would
set the 'From Mandelbrot' to (-.83, .25) and the 'To Mandelbrot' as (-.83,
-.25).	If you set the number of 'z' pixels to 128 then the program will
draw the 128 Julia sets found between Mandelbrot points (-.83, .25) and (-
.83, -.25).  To speed things up the program doesn't actually calculate ALL
the coordinates of the Julia sets.  It starts with the a pixel a the Julia
set closest to the observer and moves into the screen until it either
reaches the required bailout or the limit to the range of depth.  Zooming
can be done in the same manner as with other fractals.	The visual effect
(with other values unchanged) is similar to putting the boxed section
under a pair of magnifying glasses.

The variable associated with penetration level is the level of bailout
there you decide to make the fractal solid.  In other words all bailout
levels less than the penetration level are considered to be transparent,
and those equal or greater to be opaque.  The farther away the apparent
pixel is the dimmer the color.

The remainder of the parameters are needed to construct the red/blue
picture so that the fractal appears with the desired depth and proper 'z'
location.  With the origin set to 8 inches beyond the screen plane and the
depth of the fractal at 8 inches the default fractal will appear to start
at 4 inches beyond the screen and extend to 12 inches if your eyeballs are
2.5 inches apart and located at a distance of 24 inches from the screen.
The screen dimensions provide the reference frame.

To the human eye blue appears brighter than red.  The Blue:Red ratio is
used to compensate for this fact.  If the image appears reddish through
the glasses raise this value until the image appears to be in shades of
gray.  If it appears bluish lower the ratio.  Julibrots can only be shown
in 256 red/blue colors for viewing in either stereo-graphic (red/blue
funny glasses) or gray-scaled.	Fractint automatically loads either
GLASSES1.MAP or ALTERN.MAP as appropriate.
;
;
~Topic=Diffusion Limited Aggregation, Label=HT_DIFFUS
(type=diffusion)

This type begins with a single point in the center of the screen.
Subsequent points move around randomly until coming into contact with the
first point, at which time their locations are fixed and they are colored
randomly.  This process repeats until the fractals reaches the edge of the
screen.  Use the show orbits function to see the points' random motion.

One unfortunate problem is that on a large screen, this process will tend
to take eons.  To speed things up, the points are restricted to a box
around the initial point.  The first and only parameter to diffusion
contains the size of the border between the fractal and the edge of the
box.  If you make this number small, the fractal will look more solid and
will be generated more quickly.

Diffusion was inspired by a Scientific American article a couple of years
back which includes actual pictures of real physical phenomena that behave
like this.

Thanks to Adrian Mariano for providing the diffusion code and
documentation.
;
;
~Topic=Magnetic Fractals, Label=HT_MAGNET
(type=magnet1m/.../magnet2j)

These fractals use formulae derived from the study of hierarchical
lattices, in the context of magnetic renormalisation transformations.
This kinda stuff is useful in an area of theoretical physics that deals
with magnetic phase-transitions (predicting at which temperatures a given
substance will be magnetic, or non-magnetic).  In an attempt to clarify
the results obtained for Real temperatures (the kind that you and I can
feel), the study moved into the realm of Complex Numbers, aiming to spot
Real phase-transitions by finding the intersections of lines representing
Complex phase-transitions with the Real Axis.  The first people to try
this were two physicists called Yang and Lee, who found the situation a
bit more complex than first expected, as the phase boundaries for Complex
temperatures are (surprise!) fractals.

And that's all the technical (?) background you're getting here!  For more
details (are you SERIOUS ?!) read "The Beauty of Fractals".  When you
understand it all, you might like to re-write this section, before you
start your new job as a professor of theoretical physics...

In Fractint terms, the important bits of the above are "Fractals",
"Complex Numbers", "Formulae", and "The Beauty of Fractals".  Lifting the
Formulae straight out of the Book and iterating them over the Complex
plane (just like the Mandelbrot set) produces Fractals.

The formulae are a bit more complicated than the Z^2+C used for the
Mandelbrot Set, that's all.  They are :

~Format-
; Use this for the document...
~Online-
		   /  Z^2 + (C-1)  \\
	MAGNET1 : |  -------------  | ^ 2
		   \\  2*Z + (C-2)  /

		   /	  Z^3 + 3*(C-1)*Z + (C-1)*(C-2)      \\
	MAGNET2 : |  ---------------------------------------  | ^ 2
		   \\  3*(Z^2) + 3*(C-2)*Z + (C-1)*(C-2) - 1  /
~Online+,Doc-
; And this for online...
		  		  
		    Z^2 + (C-1)  
	MAGNET1 :    ^ 2
		    2Z + (C-2)  
		  		  
		  					    
		  	 Z^3 + 3(C-1)Z + (C-1)(C-2)	    
	MAGNET2 :    ^ 2
		    3(Z^2) + 3(C-2)Z + (C-1)(C-2) - 1  
		  					    
~Doc+
~Format+

These aren't quite as horrific as they look (oh yeah ?!) as they only
involve two variables (Z and C), but cubing things, doing division, and
eventually squaring the result (all in Complex Numbers) don't exactly
spell S-p-e-e-d !  These are NOT the fastest fractals in Fractint !

As you might expect, for both formulae there is a single related
Mandelbrot-type set (magnet1m, magnet2m) and an infinite number of related
Julia-type sets (magnet1j, magnet2j), with the usual toggle between the
corresponding Ms and Js via the spacebar.

If you fancy delving into the Julia-types by hand, you will be prompted
for the Real and Imaginary parts of the parameter denoted by C.  The
result is symmetrical about the Real axis (and therefore the initial image
gets drawn in half the usual time) if you specify a value of Zero for the
Imaginary part of C.

Fractint Historical Note:  Another complication (besides the formulae) in
implementing these fractal types was that they all have a finite attractor
(1.0 + 0.0i), as well as the usual one (Infinity).  This fact spurred the
development of Finite Attractor logic in Fractint.  Without this code you
can still generate these fractals, but you usually end up with a pretty
boring image that is mostly deep blue "lake", courtesy of Fractint's
standard {Periodicity Logic}.
See {Finite Attractors} for more
information on this aspect of Fractint internals.

(Thanks to Kevin Allen for Magnetic type documentation above).
;
;
~Topic=L-Systems, Label=HT_LSYS
(type=lsystem)

These fractals are constructed from line segments using rules specified in
drawing commands.  Starting with an initial string, the axiom,
transformation rules are applied a specified number of times, to produce
the final command string which is used to draw the image.

Like the type=formula fractals, this type requires a separate data file.
A sample file, FRACTINT.L, is included with this distribution.	When you
select type lsystem, the current lsystem file is read and you are asked
for the lsystem name you wish to run. Press <F6> at this point if you wish
to use a different lsystem file. After selecting an lsystem, you are asked
for one parameter - the "order", or number of times to execute all the
transformation rules.  It is wise to start with small orders, because the
size of the substituted command string grows exponentially and it is very
easy to exceed your resolution.  (Higher orders take longer to generate
too.)  The command line options "lname=" and "lfile=" can be used to over-
ride the default file name and lsystem name.

Each L-System entry in the file contains a specification of the angle, the
axiom, and the transformation rules.  Each item must appear on its own
line and each line must be less than 160 characters long.

The statement "angle n" sets the angle to 360/n degrees; n must be an
integer greater than two and less than fifty.

"Axiom string" defines the axiom.

Transformation rules are specified as "a=string" and convert the single
character 'a' into "string."  If more than one rule is specified for a
single character all of the strings will be added together.  This allows
specifying transformations longer than the 160 character limit.
Transformation rules may operate on any characters except space, tab or
'}'.

Any information after a ; (semi-colon) on a line is treated as a comment.

Here is a sample lsystem:

~Format-
Dragon \{	  ; Name of lsystem, \{ indicates start
  Angle 8	 ; Specify the angle increment to 45 degrees
  Axiom FX	 ; Starting character string
  F=		 ; First rule:	Delete 'F'
  y=+FX--FY+	 ; Change 'y' into  "+fx--fy+"
  x=-FX++FY-	 ; Similar transformation on 'x'
}		 ; final } indicates end

The standard drawing commands are:
    F Draw forward
    G Move forward (without drawing)
    + Increase angle
    - Decrease angle
    | Try to turn 180 degrees. (If angle is odd, the turn
      will be the largest possible turn less than 180 degrees.)
~Format+

These commands increment angle by the user specified angle value. They
should be used when possible because they are fast. If greater flexibility
is needed, use the following commands which keep a completely separate
angle pointer which is specified in degrees.

~Format-
    D	Draw forward
    M	Move forward
    \nn Increase angle nn degrees
    /nn Decrease angle nn degrees

Color control:
    Cnn Select color nn
    <nn Increment color by nn
    >nn decrement color by nn

Advanced commands:
    !	  Reverse directions (Switch meanings of +, - and \, /)
    @nnn  Multiply line segment size by nnn
	  nnn may be a plain number, or may be preceded by
	      I for inverse, or Q for square root.
	      (e.g.  @IQ2 divides size by the square root of 2)
    [	  Push.  Stores current angle and position on a stack
    ]	  Pop.	Return to location of last push
~Format+

Other characters are perfectly legal in command strings.  They are ignored
for drawing purposes, but can be used to achieve complex translations.
;
;
;
